"""
Estimator for LWR and uniform error LWE by random sampling

min_beta: beta in the first step of the two-step mode
max_beta: maximal sieving dimension the the second step of the two-step mode
sample_space, sample_vector: number of subspaces and vectors in the random sampling
type: 'uniform': both secret and error are uniform; 'gaussian': both secret and error are gaussian;
         'mixed': secret is gaussian and error is uniform

"""


# This file was *autogenerated* from the file LWR_estimator.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10 = Integer(10); _sage_const_1000 = Integer(1000); _sage_const_12 = Integer(12); _sage_const_1 = Integer(1); _sage_const_0p0 = RealNumber('0.0'); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0p = RealNumber('0.'); _sage_const_1p = RealNumber('1.'); _sage_const_1p5 = RealNumber('1.5'); _sage_const_0p5 = RealNumber('0.5')
load("sage/framework/utils.sage")

def estimate_LWR_instance(n,m,q,p,sigma_s,min_beta,max_beta,sample_space=_sage_const_10 ,sample_vector=_sage_const_1000 ):

    logvol=m*log(q)-n*log(sigma_s)-m*log((q*q-gcd(p,q)*gcd(p,q))/(p*p*_sage_const_12 ))
    compute_uniform_twostep(n,m,logvol,min_beta,max_beta,sample_space,sample_vector)

def estimate_uniform_LWE_instance(n,m,q,sigma_e,sigma_s,min_beta,max_beta,sample_space=_sage_const_10 ,sample_vector=_sage_const_1000 ):

    logvol=m*log(q)-n*log(sigma_s)-m*log(sigma_e)
    compute_uniform_twostep(n,m,logvol,min_beta,max_beta,sample_space,sample_vector,type='uniform')

def compute_uniform_twostep(n,m,logvol,min_beta,max_beta,sample_space,sample_vector,type='mixed'):

    d=n+m+_sage_const_1 

    gsap=[_sage_const_0p0 ]*max_beta
    gsap1=[_sage_const_0p0 ]*max_beta
    cum=[_sage_const_0 ]*max_beta
    cum1=[_sage_const_0 ]*max_beta
    
    delta = compute_delta(_sage_const_2 )
    l = [log(bkzgsa_gso_len(logvol, i, d, delta=delta)) / log(_sage_const_2 ) for i in range(d)]
    for beta in [x for x in range(_sage_const_2 , max_beta)]:
        l = simBKZ(l, beta, _sage_const_1 )
        delta = compute_delta(beta)
        i = d - beta
        gsap[beta] = _sage_const_2 **(_sage_const_2  * l[i])
        if(beta==min_beta):
            for beta0 in range(_sage_const_2 , max_beta):
                i0 = d - beta0
                gsap1[beta0] = _sage_const_2 **(_sage_const_2  * l[i0])

    dist = RealDistribution('gaussian',_sage_const_1 )
    X=RealDistribution('uniform',[_sage_const_0p0 -sqrt(_sage_const_3 ),sqrt(_sage_const_3 )])
    aa=[_sage_const_0p0 ]*d

    #print("------------")

    for n in range(sample_space):
        #print(n)
        subs = []
        for i in range(max_beta):
            subs.append([dist.get_random_element() for _ in range(d)])
        for i in range(max_beta):
            for j in range(i):
                a=_sage_const_0p0 
                b=_sage_const_0p0 
                for k in range(d):
                    a=a+subs[i][k]*subs[j][k]
                    b=b+subs[j][k]*subs[j][k]
                for k in range(d):
                    subs[i][k]=subs[i][k]-subs[j][k]*a/b
            c=_sage_const_0p0 
            for k in range(d):
                c=c+subs[i][k]*subs[i][k]
            for k in range(d):
                subs[i][k]=subs[i][k]/sqrt(c)

        for j in range(sample_vector):
            #if((j%100)==0):
            #    print(j)
            if(type=='gaussian'):
                for i in range(m):
                    aa[i]=dist.get_random_element()
            else:
                for i in range(m):
                    aa[i]=X.get_random_element()
            if(type=='uniform'):
                for i in range(m,m+n):
                    aa[i]=X.get_random_element()
                for i in range(m,m+n):
                    aa[i]=dist.get_random_element()
            aa[d-_sage_const_1 ]=_sage_const_1 
            len=_sage_const_0p0 
            for k in range(max_beta-_sage_const_1 ):
                proj=_sage_const_0p0 
                for i in range(d):
                    proj = proj + subs[k][i]*aa[i]
                len=len+proj*proj
                if(len<gsap[k+_sage_const_1 ]):
                    cum[k+_sage_const_1 ]=cum[k+_sage_const_1 ]+_sage_const_1 
                if(len<gsap1[k+_sage_const_1 ]):
                    cum1[k+_sage_const_1 ]=cum1[k+_sage_const_1 ]+_sage_const_1 

    average_beta=_sage_const_0p 
    cumulated_proba=_sage_const_0p 
    remaining_proba=_sage_const_1p 
    for beta in range(_sage_const_2 ,max_beta):
        average_beta += beta * remaining_proba * cum[beta] / sample_vector / sample_space
        cumulated_proba += remaining_proba * cum[beta] / sample_vector / sample_space
        remaining_proba *= _sage_const_1p  - cum[beta] / sample_vector / sample_space

    print("leaky-LWR-estimator: average-beta:")
    print(average_beta)
    print(remaining_proba)
    print("---------------")

    cumulated_time=_sage_const_0p 
    cumulated_proba=_sage_const_0p 
    remaining_proba=_sage_const_1p 
    for beta in range(_sage_const_2 ,max_beta):
        cumulated_time += (_sage_const_1p5  ** (_sage_const_0p5 *beta)) * (cum1[beta] / sample_vector / sample_space - cumulated_proba)
        cumulated_proba = cum1[beta] / sample_vector / sample_space
        remaining_proba = _sage_const_1p  - cum1[beta] / sample_vector / sample_space

    print("two-step-LWR-estimator: average-d_svp:")
    print(log(cumulated_time)/log(sqrt(_sage_const_1p5 )))
    print(remaining_proba)

