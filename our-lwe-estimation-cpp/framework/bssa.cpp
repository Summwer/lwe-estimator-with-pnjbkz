#include "bssa.h"


void BSSA::print_strategy(vector<BSSA::strategy> S){
    cout<<"Block size strategy generated by BSSA (beta,jump,tours):{";
    for(int i =0; i < S.size(); i ++){
        printf("(%3d,%3d,%3d)",S[i].beta,S[i].jump,S[i].tours);
    }
    cout<<"}"<<endl;
}

void BSSA::dsvp_predict(vector<double> l, int beta, double cum_pr, bool progressive_sieve){
    if(progressive_sieve)
        progressive_dsvp_predict(l, beta, cum_pr);
    else
        fixed_dsvp_predict(l, beta, cum_pr);
}

double BSSA::fixed_dsvp_predict(vector<double> l, int beta, double cum_pr){
    int d = l.size();
    double psvp, p, rp, gh;
    if(cum_pr >= 1.){
        return 0.;
    }
    for(int dsvp = 50; dsvp < d; dsvp++ ){
        //2**(2 * l1[d-dsvp])==2**(2 * l1d_dsvp)==gh
        gh = gaussian_heuristic_log2(l,d-dsvp);
        
        boost::math::chi_squared chisquare(dsvp);
        psvp = boost::math::cdf(chisquare,gh); //Compute chi-squared value
        
        p = cum_pr + (1. - cum_pr)* psvp;
        // cout<<dsvp<<","<<gh<<","<<p<<endl;
        rp = 1. - p;
        if(rp < 0.001){
            return  dsvp + dsvp * rp;  //Avoid too small of dsvp
        }
    }
    return d;
}

void BSSA::progressive_dsvp_predict(vector<double> l, int beta, double cum_pr){
    int d = l.size();
    double psvp, p, rp, gh;
    if(cum_pr >= 1.){
        return 0.;
    }
    for(int dsvp = 50; dsvp < d; dsvp++ ){
        //2**(2 * l1[d-dsvp])==2**(2 * l1d_dsvp)==gh
        gh = gaussian_heuristic_log2(l,d-dsvp);
        
        boost::math::chi_squared chisquare(dsvp);
        psvp = boost::math::cdf(chisquare,gh); //Compute chi-squared value
        
        p = cum_pr + (1. - cum_pr)* psvp;
        // cout<<dsvp<<","<<gh<<","<<p<<endl;
        rp = 1. - p;
        if(rp < 0.001){
            return  dsvp + dsvp * rp;  //Avoid too small of dsvp
        }
    }
    return d;
}


int BSSA::min_tour_to_each_goal_dsvp(vector<double> l0,double cumulated_proba0,int beta, int jump, double goal_dsvp){
    /*
    input: l0 -- log2(||b_i^*||) gs-lengths
            cum_pr -- cumulated probability of success in reduction for current gs-lengths
            beta -- simulated block size for pnj-bkz-beta-jump
            jump -- jump value for simulated pnj-bkz-beta-jump
    output: 
        dsvp -- reduced basis quality dsvp, 
        loop -- minimal loop of pnj-bkz-beta-jump in reduction.
    */

    int d = l0.size(), loop = 0;
    double dsvp0, dsvp1, proba;
    
    vector<double> l1;
    l1.resize(d);
    dsvp1 = dsvp_predict(l0, beta, cum_pr);
    do{
        dsvp0 = dsvp1;
        sim -> sim_above_45(l1, l0, beta,jump, 1); 
        dsvp1 = dsvp_predict(l1, beta, cum_pr);

        boost::math::chi_squared chisquare(beta);   
        proba = boost::math::cdf(chisquare,pow(2,(2. * l1[d-beta])));
        cum_pr = cum_pr + (1.-cum_pr) * proba;
        l0 = l1;
        loop += 1;
        
    }while(dsvp0 - dsvp1 > 1);
    
    return make_pair(dsvp0,loop-1);

}


pair<double,int> BSSA::max_tour_for_pnjbkz_beta(vector<double> l0, double cum_pr,int beta, int jump){
    /*
    input: l0 -- log2(||b_i^*||) gs-lengths
            cum_pr -- cumulated probability of success in reduction for current gs-lengths
            beta -- simulated block size for pnj-bkz-beta-jump
            jump -- jump value for simulated pnj-bkz-beta-jump
    output: 
        dsvp -- reduced basis quality dsvp, 
        loop -- maximal loop of pnj-bkz-beta-jump in reduction.
    */

    int d = l0.size(), loop = 0;
    double dsvp0, dsvp1, proba;
    
    vector<double> l1;
    l1.resize(d);
    dsvp1 = dsvp_predict(l0, beta, cum_pr);
    do{
        dsvp0 = dsvp1;
        sim -> sim_above_45(l1, l0, beta,jump, 1); 
        dsvp1 = dsvp_predict(l1, beta, cum_pr);

        boost::math::chi_squared chisquare(beta);   
        proba = boost::math::cdf(chisquare,pow(2,(2. * l1[d-beta])));
        cum_pr = cum_pr + (1-cum_pr) * proba;
        l0 = l1;
        loop += 1;
        
    }while(dsvp0 - dsvp1 > 1);
    
    return make_pair(dsvp0,loop-1);

}

void BSSA::bssa_generate(vector<double> l0, int beta_start, int beta_goal, int jump, int gap, int J_gap){
    /*
    param: node_start, node_goal, node_mid, node
    */
    int d= l0.size();
    int node, node_start, node_goal = 0, node_mid, beta;
    int dsvp_star = ceil(dsvp_predict(l0, 0, 0.));
    node_start = -dsvp_star; //quality increase while value of dsvp decreases.

    double G_min,G_tmp;

    for(node_mid = node_start; node_mid <= node_goal; node_mid+= max(gap,1)){
        G_min = MAX_NUM;
        for(node = node_start; node < node_mid; node += max(gap,1)){
            printf("\r Blocksize strategy selection process: %4d --> %4d  --> %4d --> %4d", node_start,node,node_mid,node_goal);
            if(node == node_start){
                bs0 = {{},l0,0.,0.};
            }
            else if(node > node_start){
                if(BS.find(node)==BS.end()){
                    bssa_generate(l0, node_start, node);
                }else{
                    bs0 = BS[node];
                }
            }

            G_tmp = MAX_NUM;
            //node_tmp = MAX_DIM;
            //beta = max(bs0.S);
            print_strategy(bs0.S);
            // dsvp_star = d - beta_sstart
            beta = 50;
            for(int beta_alg = beta+1; beta_alg < min(MAX_DIM,d); beta_alg++){
                printf("\r Blocksize strategy selection process: %4d --> %4d --> (%4d) --> %4d --> %4d", node_start,node,beta_alg,node_mid,node_goal);
                if (beta_alg >= beta_tmp + 3)
                    break
                for(int j=1; j < J+1; j+=J_gap){
                    if(G_tmp == 0)
                        break;
                    l_, _, loop_, G_, cumulated_proba_= min_tour_to_each_goal_dsvp(l,cum_pr,beta,jump=j,dsvp_star = dsvp_star);
                        
                //     if G_tmp > G_:
                //         S_tmp, l_tmp, G_tmp, cumulated_proba_tmp,beta_tmp =[(beta_alg,j) for _ in range(loop_)], l_,  G_,cumulated_proba_, beta_alg
                }
            }
        }
    }
    printf("\n");
}